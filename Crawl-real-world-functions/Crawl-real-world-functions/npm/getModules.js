const names = require("all-the-package-names").filter(name => name === name.toLowerCase());
const child_process = require("child_process");
const fetch = require("node-fetch-commonjs");
const {getFunctions} = require("./getFunctions.js");
const fs = require("fs");

async function m(){

    let totalFuncs = 0;
    let fileStream = fs.createWriteStream("./data/npmFunctions.json", {flags:'a'});
    const errorFileStream = fs.createWriteStream("./errors/errorPackages.json",  {flags:'a'});

    for(let i = 0; i < names.length; i++) {

        if (i % 50 === 0) {
            fileStream.close();
            fileStream = fs.createWriteStream(`./data/npmFunctions${i}.json`, {flags:'a'})
        }

        let pname = names[i];
        console.log(pname);
        console.time();
        let repoName = "";
        //get the repositories of all package names
        try{
            const answ = child_process.execSync(`npm view ${pname} repository.url`).toString();
            repoName = answ.match(/git(?:\+https)?:\/\/github\.com\/(.*)\.git/)?.[1];
        }
        catch(e){
            console.log(e.toString());
        }
        if (!repoName) {
            console.log("no repository")
            continue;
        }
        let searchResults = [];

        //get search results from github
        const responseFirst = await fetch(`https://api.github.com/search/code?q=-spec+in:path+extension:js+repo:${repoName}&per_page=100`)
        .then(res => res.json());
        searchResults = searchResults.concat(responseFirst.items);
        if(!responseFirst.total_count){
            errorFileStream.write(JSON.stringify(repoName) + ", \n" );
        }
        const totalPages = Math.ceil(responseFirst.total_count / 100);
        console.log("totalPages: " + totalPages);
        for(let i = 2; i<=totalPages; i++){
            const responseNext = await fetch(`https://api.github.com/search/code?q=-spec+in:path+extension:js+repo:${repoName}&per_page=100&page=${i}`)
            .then(res => res.json());
            searchResults = searchResults.concat(responseNext.items || []);
        }

        // get links to github for each found file
        const fileLinks = searchResults
            .filter(Boolean)
            .map(node => node.html_url)
            .filter(link => !link.includes("test") || !link.includes("spec"))
            .map(link => {
                const sections = link.split(/\/+/);
                sections[1] = "/raw.githubusercontent.com";
                sections.splice(4, 1);
                return sections.join("/");
            });
        let validFileCounter = 0;
        //for each link, get all functions
        for(const fileLink of fileLinks){
            const fileStr = await fetch(fileLink)
                .then(res => res.text());
            
            if(fileStr.includes("function")){
                const functions = await getFunctions(fileStr, fileLink);
                if(functions?.length) {
                    validFileCounter++;
                    totalFuncs += functions.length;
                    const functionDescriptors = functions.map((func) => ({
                        function: func,
                        fileLink,
                    }));
                    
                    for (const desc of functionDescriptors) {
                        fileStream.write(JSON.stringify(desc) + ", \n");
                    }
                
                }
            }
            if(totalFuncs == 7040){
               break;         
            }

        }
        console.log("total count: ", responseFirst.total_count);
        console.log("file count: ", validFileCounter);
        console.timeEnd();

    }

}

m();
