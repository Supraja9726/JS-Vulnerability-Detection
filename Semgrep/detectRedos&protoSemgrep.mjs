import fs from "fs";        // import filesystem
import { evilRegExes } from "./utils.mjs";   // import evilRegExes function from the file utils.js
import { semgrep } from "./utils.mjs";   // import semgrep function from the file utils.js

// execute the tool: node "detectRedos&protoSemgrep.mjs" path/to/functions path/to/outputJSON path/to/protoRules path/to/RedosRules
 
const INPUT = process.argv[2];  // gets the Input arguments passed to the node.js process when given in the command line 
const OUTPUT = process.argv[3]; // gets the Output arguments passed to the node.js process when given in the command line 

const PROTORULES = process.argv[4]; // gets the Prototype pollution rules file arguments passed to the node.js process when given in the command line 
const REDOSRULES = process.argv[5]; // gets the ReDOS rules file arguments passed to the node.js process when given in the command line

// Prints all Input data -- debug
console.log("Input:",INPUT);
console.log("Output:",OUTPUT);
console.log("ProtoRules:",PROTORULES);
console.log("RedosRules:",REDOSRULES);

const data = JSON.parse(fs.readFileSync(INPUT)); // reads the Input file and returns the content, sets in in "data"
console.log("Total Data:",data);  // debug

console.log("Starting proto_semgrep: ", new Date());
let start = 0;
let i = 0;


for(const vuln of data){
    i++;  
    console.time("Single file"); // Measures how long it takes to run this particular file - Time Starts 

    console.log("Vuln:",vuln);  // Check the value in vuln -- debug
    console.log("vuln function:",vuln.function); // Debug
    
// calling semgrep function from the file utils.js; passes arguments - vuln.function, path to protype pollution rules, sets the output of the function in "protoResults"
    const protoResults = semgrep(vuln.function, PROTORULES)  
    console.log("Protoresults:",protoResults);  // Debug
    
    if (protoResults) {        // Executes is protoResults is not empty - function is then vulnerable to Prototype pollution
        vuln.protoPollution = true;
        vuln.matches = protoResults;
    }

// Calling evilRegExes function from the file utils.js; passes argument - vuln-function, sets the output of the funtion in "regexes"
    const regexes = evilRegExes(vuln.function);   
    console.log("Regexes:",regexes);  // Debug
    console.log("Regex length:",regexes.length);  // Debug
   
    
    if (regexes.length) {     // Executes if regexes.length is non-empty non-zero.
        vuln.evilRe = regexes;
        
        const redosResults = semgrep(vuln.function, REDOSRULES)  // calling semgrep function from utils.js; passes arguments - vuln.function, path to ReDos rules
        if (redosResults) {        //Executes if redosResults is not empty - function is then vulnerable to ReDos
            vuln.redos = true;
            vuln.matches = redosResults;
        }
    }
    
    if (vuln.evilRe || vuln.protoPollution) {      // If the function is vulnerable to any one of the two vulnerabilites, it is written and appended into the output file in JSON format.
        fs.appendFileSync(OUTPUT, JSON.stringify(vuln) + ",\n");
    }
  
    fs.writeFileSync("./lastIndex.txt", i.toString());
    console.timeEnd("Single file");         // Measures how long it takes to run this particular file - Time Ends 
    console.log("********************" +i + " out of " + (data.length+start)+"******************"); // Prints current iteration out of the total number of iterations
}

console.log("semgrep done", new Date());  // Marks the end of Semgrep analysis
