rules:
- id: prototype-polution1
  patterns:
    - pattern-either: 
      - pattern: |
          $SOME_OBJ[$KEY] = ...
      - pattern: |
          $SOME_OBJ[$KEY[...]] = ...
    - pattern-not: |
        $SOME_OBJ[$KEY] = $SOME_OBJ[$KEY] || $SOMETHING_ELSE
    - pattern-not: |
        $SOME_OBJ[$KEY[$INDEX]] = $SOME_OBJ[$KEY[$INDEX]] || $SOMETHING_ELSE
    - pattern-not: |
        $SOME_OBJ[$KEY] = $SOME_OBJ[$KEY] ? $SOME_OBJ[$KEY] : $SOMETHING_ELSE
    - pattern-not: |
        $SOME_OBJ[$KEY[$INDEX]] = $SOME_OBJ[$KEY[$INDEX]] ? $SOME_OBJ[$KEY[$INDEX]] : $SOMETHING_ELSE
    - pattern-either:
        - pattern-inside: |
            function ... (...,$OBJ,...) {
              ...
            }
        - pattern-inside: | 
            function ...(...) {
            ...
            $OBJ = arguments[...]
            ...
            }
        - pattern-inside: |
            function ...(...,$ARG,...) {
            ...
            $OBJ = <... $ARG ...>
            ...
            }
        - pattern-inside: |
            function ...(...$ARG) {
              ...
              $OBJ = $ARG[...]
              ...
            }
        
    - pattern-either:
      - pattern-inside: |
          Object.keys($OBJ).$METHOD(function (...,$KEY,...) {
            ...
          })
    - metavariable-regex:
          metavariable: $METHOD
          regex: (forEach|map|flatMap)
    - pattern-not-regex: |
        ((__proto__[\s\S]*prototype[\s\S]*constructor)|(__proto__[\s\S]*constructor[\s\S]*prototype)|(prototype[\s\S]*__proto__[\s\S]*constructor)|(prototype[\s\S]*constructor[\s\S]*__proto__)|(constructor[\s\S]*__proto__[\s\S]*prototype)|(constructor[\s\S]*prototype[\s\S]*__proto__))[\s\S]*
    - pattern-not-regex: |
        Object\.freeze\([\s\S]*
    - pattern-not-regex: |
        Object\.create\(null\)[\s\S]*
  message: usage of Object.keys on object from arguments
  severity: WARNING
  languages: [javascript]


- id: prototype-polution2
  patterns:
    - pattern-either: 
      - pattern: |
          $SOME_OBJ[$KEY] = ...
      - pattern: |
          $SOME_OBJ[$KEY[...]] = ...
    - pattern-not: |
        $SOME_OBJ[$KEY] = $SOME_OBJ[$KEY] || $SOMETHING_ELSE
    - pattern-not: |
        $SOME_OBJ[$KEY[$INDEX]] = $SOME_OBJ[$KEY[$INDEX]] || $SOMETHING_ELSE
    - pattern-not: |
        $SOME_OBJ[$KEY] = $SOME_OBJ[$KEY] ? $SOME_OBJ[$KEY] : $SOMETHING_ELSE
    - pattern-not: |
        $SOME_OBJ[$KEY[$INDEX]] = $SOME_OBJ[$KEY[$INDEX]] ? $SOME_OBJ[$KEY[$INDEX]] : $SOMETHING_ELSE
    - pattern-either:
      - pattern-inside: |
          function ...(...,$ARG,...) {
            ...
            $KEYS = <...$ARG...>
            ...
          }
      - pattern-inside: |
          function ...(...,$OBJ,...,$KEYS,...) {
            ...
          }
    - pattern-inside: |
        $KEYS.$METHOD(function (...,$KEY,...) {
          ...
        })
    - metavariable-regex:
          metavariable: $METHOD
          regex: (forEach|map|flatMap)
    - pattern-not-regex: |
        ((__proto__[\s\S]*prototype[\s\S]*constructor)|(__proto__[\s\S]*constructor[\s\S]*prototype)|(prototype[\s\S]*__proto__[\s\S]*constructor)|(prototype[\s\S]*constructor[\s\S]*__proto__)|(constructor[\s\S]*__proto__[\s\S]*prototype)|(constructor[\s\S]*prototype[\s\S]*__proto__))[\s\S]*
    - pattern-not-regex: |
        Object\.freeze\([\s\S]*
    - pattern-not-regex: |
        Object\.create\(null\)[\s\S]*
  message: iteration of keys, and object assignment (keys from arguments)
  severity: WARNING
  languages: [javascript]

- id: prototype polution21
  patterns:
    - pattern-either: 
      - pattern: |
          $SOME_OBJ[$KEY] = ...
      - pattern: |
          $SOME_OBJ[$KEY[...]] = ...
    - pattern-not: |
        $SOME_OBJ[$KEY] = $SOME_OBJ[$KEY] || $SOMETHING_ELSE
    - pattern-not: |
        $SOME_OBJ[$KEY[$INDEX]] = $SOME_OBJ[$KEY[$INDEX]] || $SOMETHING_ELSE
    - pattern-not: |
        $SOME_OBJ[$KEY] = $SOME_OBJ[$KEY] ? $SOME_OBJ[$KEY] : $SOMETHING_ELSE
    - pattern-not: |
        $SOME_OBJ[$KEY[$INDEX]] = $SOME_OBJ[$KEY[$INDEX]] ? $SOME_OBJ[$KEY[$INDEX]] : $SOMETHING_ELSE
    - pattern-either:
      - pattern-inside: |
          function ...(...,$ARG,...) {
            ...
            $KEYS = <...$ARG...>
            ...
          }
      - pattern-inside: |
          function ...(...) {
          ...
          $KEYS = arguments[...]
          ...
          }
    - pattern-inside: |
        for ($KEY in $KEYS) 
            ...
        
    - pattern-not-regex: |
        ((__proto__[\s\S]*prototype[\s\S]*constructor)|(__proto__[\s\S]*constructor[\s\S]*prototype)|(prototype[\s\S]*__proto__[\s\S]*constructor)|(prototype[\s\S]*constructor[\s\S]*__proto__)|(constructor[\s\S]*__proto__[\s\S]*prototype)|(constructor[\s\S]*prototype[\s\S]*__proto__))[\s\S]*
    - pattern-not-regex: |
        Object\.freeze\([\s\S]*
    - pattern-not-regex: |
        Object\.create\(null\)[\s\S]*
  message: (temp)
  severity: WARNING
  languages: [javascript]


- id: prototype polution3
  patterns:
    - pattern-either: 
      - pattern: |
          $SOME_OBJ[$KEY] = ...
    - pattern-not: |
        $SOME_OBJ[$KEY] = $SOME_OBJ[$KEY] || $SOMETHING_ELSE
    - pattern-not: |
        $SOME_OBJ[$KEY] = $SOME_OBJ[$KEY] ? $SOME_OBJ[$KEY] : $SOMETHING_ELSE
    - pattern-inside: |
          function ...(...,$OBJ,...) {
            ...
          }
    - pattern-inside: |
        for ($KEY in $OBJ) 
            ...
    - pattern-not-regex: |
        ((__proto__[\s\S]*prototype[\s\S]*constructor)|(__proto__[\s\S]*constructor[\s\S]*prototype)|(prototype[\s\S]*__proto__[\s\S]*constructor)|(prototype[\s\S]*constructor[\s\S]*__proto__)|(constructor[\s\S]*__proto__[\s\S]*prototype)|(constructor[\s\S]*prototype[\s\S]*__proto__))[\s\S]*
    - pattern-not-regex: |
        Object\.freeze\([\s\S]*
    - pattern-not-regex: |
        Object\.create\(null\)[\s\S]*
  message: loop through keys in object 
  severity: WARNING
  languages: [javascript]

- id: prototype-polution4
  patterns:
    - pattern-either: 
      - pattern: |
          $SOME_OBJ[$KEY] = ...
      - pattern: |
          $SOME_OBJ[$KEY[...]] = ...
    - pattern-not: |
        $SOME_OBJ[$KEY] = $SOME_OBJ[$KEY] || $SOMETHING_ELSE
    - pattern-not: |
        $SOME_OBJ[$KEY[$INDEX]] = $SOME_OBJ[$KEY[$INDEX]] || $SOMETHING_ELSE
    - pattern-not: |
        $SOME_OBJ[$KEY] = $SOME_OBJ[$KEY] ? $SOME_OBJ[$KEY] : $SOMETHING_ELSE
    - pattern-not: |
        $SOME_OBJ[$KEY[$INDEX]] = $SOME_OBJ[$KEY[$INDEX]] ? $SOME_OBJ[$KEY[$INDEX]] : $SOMETHING_ELSE
    - pattern-either: 
      - pattern-inside: |
          function ...(...,$ARG,...) {
            ...
            $KEY0 = <...$ARG...>
            ...
            $KEY = <...$KEY0...>
            ...
          }  
      - pattern-inside: |
          function ...(...,$OBJ0,...,$KEY0,...) {
            ...
            $KEY = <...$KEY0...>
            ...
            $SOME_OBJ = <...$OBJ0...>
            ...
          }
      - pattern-inside: |
          function ...(..., $PATH,...) {
            ...
            $KEY = <...$PATH...>
            ...
          }
    - pattern-not-regex: |
        ((__proto__[\s\S]*prototype[\s\S]*constructor)|(__proto__[\s\S]*constructor[\s\S]*prototype)|(prototype[\s\S]*__proto__[\s\S]*constructor)|(prototype[\s\S]*constructor[\s\S]*__proto__)|(constructor[\s\S]*__proto__[\s\S]*prototype)|(constructor[\s\S]*prototype[\s\S]*__proto__))[\s\S]*
    - pattern-not-regex: |
        Object\.freeze\([\s\S]*
    - pattern-not-regex: |
        Object\.create\(null\)[\s\S]*
    - pattern-not-inside: |
        <...$KEY += "..."...>
        ...
    - pattern-not-inside: |
        <...$KEY = $STR + "..."...>
        ...
    - pattern-not-inside: |
        <...$KEY = "..." + $STR...>
        ...
    - pattern-not-inside: |
        <...$KEY++...>
        ...
    - pattern-not-inside: |
        <...$KEY--...>
        ...
    - pattern-not-inside: |
        <...$KEY = $NUM1 - $NUM2...>
        ...
    - pattern-not-inside: |
        <...$KEY -= $NUM1...>
        ...
    - pattern-not-inside: |
        while($KEY--) {
          ...
        }
    - pattern-not-inside: |
        while($KEY++) {
          ...
        }

  message: FP DANGER. assignment to obj[key] (key reassigned from arguments). (typical for obj,path,value) 
  severity: WARNING
  languages: [javascript]

- id: prototype-polution5
  patterns:
    - pattern-either: 
      - pattern: |
          $OBJ2[$KEY3] = ...
    - pattern-inside: |
          function ...(...,$OBJ,...,$KEYS,...) {
            ...
            $OBJ2 = <...$OBJ...>
            ...
          }
    - pattern-inside: |
        $KEYS.$METHOD(function (...,$KEY,...) {
          ...
          $KEY2 = <...$KEY...>
          ...
          $KEY3 = <...$KEY2...>
          ...
        })
    - metavariable-regex:
          metavariable: $METHOD
          regex: (forEach|map|flatMap)
    - pattern-not-regex: |
        ((__proto__[\s\S]*prototype[\s\S]*constructor)|(__proto__[\s\S]*constructor[\s\S]*prototype)|(prototype[\s\S]*__proto__[\s\S]*constructor)|(prototype[\s\S]*constructor[\s\S]*__proto__)|(constructor[\s\S]*__proto__[\s\S]*prototype)|(constructor[\s\S]*prototype[\s\S]*__proto__))[\s\S]*
    - pattern-not-regex: |
        Object\.freeze\([\s\S]*
    - pattern-not-regex: |
        Object\.create\(null\)[\s\S]*
  message: assignment of obj[key] without key check (obj reassigned 1 time, key - 2 times) 
  severity: WARNING
  languages: [javascript]

- id: prototype-polution6
  patterns:
    - pattern-either: 
      - pattern: $TARGET[$KEY] = ...
    - pattern-inside: |
          function ...(...,$ARG,...) {
            ...
            $TARGET = $ARG[...]
            ...
            $KEYS = $ARG[...]
            ...
            $KEYS2 = Object.keys($KEYS)
            ...
            $KEY = <...$KEYS2...>
            ...
          }
    - pattern-not-regex: |
        ((__proto__[\s\S]*prototype[\s\S]*constructor)|(__proto__[\s\S]*constructor[\s\S]*prototype)|(prototype[\s\S]*__proto__[\s\S]*constructor)|(prototype[\s\S]*constructor[\s\S]*__proto__)|(constructor[\s\S]*__proto__[\s\S]*prototype)|(constructor[\s\S]*prototype[\s\S]*__proto__))[\s\S]*
    - pattern-not-regex: |
        Object\.freeze\([\s\S]*
    - pattern-not-regex: |
        Object\.create\(null\)[\s\S]*
  message: accessing obj[key], where obj and keys are from 1 common argument
  severity: WARNING
  languages: [javascript]

{"function":"function (n) {\n  if (n === '.') return 1\n  return Buffer.byteLength(n) + 2\n}","vector":"function ( varName1 ) { if ( varName1 === '.' ) return 1 return Buffer . byteLength ( varName1 ) + 2 }","hash":"44b10dbf9c43dd647d211cc7216f2636efae9050","simhash":13794217694856978000,"link":"https://github.com/mafintosh/dns-packet/commit/25f15dd0fedc53688b25fd053ebbdffe3d5c1c56","page":"https://snyk.io/vuln/SNYK-JS-DNSPACKET-1293563","CVE":"CVE-2021-23386","CWE":"CWE-201","packageName":"dns-packet","versions":"<5.2.2","details":"Remote Memory Exposure. dns-packet is an An abstract-encoding compliant module for encoding / decoding DNS packetsAffected versions of this package are vulnerable to Remote Memory Exposure. It creates buffers with allocUnsafe and does not always fill them before forming network packets. This can expose internal application memory over unencrypted network when querying crafted invalid domain names.","vulnType":"Remote Memory Exposure","fileLink":"https://github.com/mafintosh/dns-packet/raw/c11116822afcdaab05ccd9f76549e9089bb44f47/index.js","protoPollution":true,"matches":[]},
{"function":"function trailingSlash () {\n    var args = Array.prototype.slice.call(arguments)\n    var done = middleware ? args.slice(-1)[0] : next\n\n    var req = args[0]\n    var res = args[1]\n    var url = u.parse(req.url)\n    var length = url.pathname.length\n    var hasSlash = url.pathname.charAt(length - 1) === '/'\n\n    if (hasSlash === slash) {\n      if (middleware) {\n        return done()\n      }\n      return next.apply(null, args)\n    }\n\n    if (slash) {\n      url.pathname = url.pathname + '/'\n    } else {\n      url.pathname = url.pathname.slice(0, -1)\n    }\n\n    res.statusCode = status\n    res.setHeader('Location', u.format(url))\n    res.end()\n  }","vector":"function trailingSlash ( ) { var varName1 = Array . prototype . slice . call ( arguments ) var varName2 = middleware ? varName1 . slice ( - 1 ) [ 0 ] : next var varName3 = varName1 [ 0 ] var varName4 = varName1 [ 1 ] var varName5 = u . parse ( varName3 . url ) var varName6 = varName5 . pathname . length var varName7 = varName5 . pathname . charAt ( varName6 - 1 ) === '/' if ( varName7 === slash ) { if ( middleware ) { return varName2 ( ) } return next . apply ( null , varName1 ) } if ( slash ) { varName5 . pathname = varName5 . pathname + '/' } else { varName5 . pathname = varName5 . pathname . slice ( 0 , - 1 ) } varName4 . statusCode = status varName4 . setHeader ( 'Location' , u . format ( varName5 ) ) varName4 . end ( ) }","hash":"897a2790d6c289f98f76005af277c97a94bcb217","simhash":3422234256235240000,"link":"https://github.com/fardog/trailing-slash/commit/f8e66f1429308247e5a119d430203077d8f05048","page":"https://snyk.io/vuln/SNYK-JS-TRAILINGSLASH-1085707","CVE":"CVE-2021-23387","CWE":"CWE-601","packageName":"trailing-slash","versions":"<2.0.1","details":"Open Redirect. trailing-slash is an Add or remove trailing slashes, and redirect.Affected versions of this package are vulnerable to Open Redirect via the use of trailing double slashes in the URL when accessing the vulnerable endpoint (such as https://example.com//attacker.example/). The vulnerable code is in index.js::createTrailing(), as the web server uses relative URLs instead of absolute URLs.","vulnType":"Open Redirect","fileLink":"https://github.com/fardog/trailing-slash/raw/003b706cb00e09b2b759855684ca72274de40ba8/index.js","protoPollution":true,"matches":[]},
{"function":"obj => {\n    if (typeof obj !== 'object') return;\n    if (Array.isArray(obj)) {\n      obj.forEach((_, index) => {\n        src = target[index];\n        val = obj[index];\n        if (val === target) {\n        } else if (typeof val !== 'object' || val === null) {\n          target[index] = val;\n        } else if (isSpecificValue(val)) {\n          target[index] = cloneSpecificValue(val);\n        } else if (typeof src !== 'object' || src === null) {\n          if (Array.isArray(val)) {\n            target[index] = override([], val);\n          } else {\n            target[index] = override({}, val);\n          }\n        } else {\n          target[index] = override(src, val);\n        }\n        return;\n      });\n    } else {\n      Object.keys(obj).forEach(key => {\n        src = target[key];\n        val = obj[key];\n        if (val === target) {\n        } else if (typeof val !== 'object' || val === null) {\n          target[key] = val;\n        } else if (isSpecificValue(val)) {\n          target[key] = cloneSpecificValue(val);\n        } else if (typeof src !== 'object' || src === null) {\n          if (Array.isArray(val)) {\n            target[key] = override([], val);\n          } else {\n            target[key] = override({}, val);\n          }\n        } else {\n          target[key] = override(src, val);\n        }\n        return;\n      });\n    }\n  }","vector":"varName4 => { if ( typeof varName4 !== 'object' ) return ; if ( Array . isArray ( varName4 ) ) { varName4 . forEach ( ( varName1 , varName2 ) => { src = target [ index ] ; val = varName4 [ index ] ; if ( val === target ) { } else if ( typeof val !== 'object' || val === null ) { target [ index ] = val ; } else if ( isSpecificValue ( val ) ) { target [ index ] = cloneSpecificValue ( val ) ; } else if ( typeof src !== 'object' || src === null ) { if ( Array . isArray ( val ) ) { target [ index ] = override ( [ ] , val ) ; } else { target [ index ] = override ( { } , val ) ; } } else { target [ index ] = override ( src , val ) ; } return ; } ) ; } else { Object . keys ( varName4 ) . forEach ( varName3 => { src = target [ key ] ; val = varName4 [ key ] ; if ( val === target ) { } else if ( typeof val !== 'object' || val === null ) { target [ key ] = val ; } else if ( isSpecificValue ( val ) ) { target [ key ] = cloneSpecificValue ( val ) ; } else if ( typeof src !== 'object' || src === null ) { if ( Array . isArray ( val ) ) { target [ key ] = override ( [ ] , val ) ; } else { target [ key ] = override ( { } , val ) ; } } else { target [ key ] = override ( src , val ) ; } return ; } ) ; } }","hash":"bfb23dd1c0304710c6abde243feb9b4f51a90bac","simhash":3403650376737726500,"link":"https://github.com/ASaiAnudeep/deep-override/commit/2aced17651fb684959a6e04b1465a8329b3d5268","page":"https://snyk.io/vuln/SNYK-JS-DEEPOVERRIDE-1292344","CVE":"CVE-2021-25941","CWE":"CWE-1321","packageName":"deep-override","versions":"<1.0.2","details":"Prototype Pollution. deep-override is a recursive object extending &amp; overridingAffected versions of this package are vulnerable to Prototype Pollution in &#39;deep-override&#39;. It allows an attacker to cause a denial of service and may lead to remote code execution.","vulnType":"Prototype Pollution","fileLink":"https://github.com/ASaiAnudeep/deep-override/raw/393135641fb0891409ac2a53783c553a7ed749a9/src/index.js","protoPollution":true,"matches":[]},
{"function":"function override(...rawArgs) {\n  if (rawArgs.length < 1 || typeof rawArgs[0] !== 'object') return false;\n  if (rawArgs.length < 2) return rawArgs[0];\n  const target = rawArgs[0];\n  const args = Array.prototype.slice.call(rawArgs, 1);\n  let val, src;\n  args.forEach(obj => {\n    if (typeof obj !== 'object') return;\n    if (Array.isArray(obj)) {\n      obj.forEach((_, index) => {\n        src = target[index];\n        val = obj[index];\n        if (val === target) {\n        } else if (typeof val !== 'object' || val === null) {\n          target[index] = val;\n        } else if (isSpecificValue(val)) {\n          target[index] = cloneSpecificValue(val);\n        } else if (typeof src !== 'object' || src === null) {\n          if (Array.isArray(val)) {\n            target[index] = override([], val);\n          } else {\n            target[index] = override({}, val);\n          }\n        } else {\n          target[index] = override(src, val);\n        }\n        return;\n      });\n    } else {\n      Object.keys(obj).forEach(key => {\n        src = target[key];\n        val = obj[key];\n        if (val === target) {\n        } else if (typeof val !== 'object' || val === null) {\n          target[key] = val;\n        } else if (isSpecificValue(val)) {\n          target[key] = cloneSpecificValue(val);\n        } else if (typeof src !== 'object' || src === null) {\n          if (Array.isArray(val)) {\n            target[key] = override([], val);\n          } else {\n            target[key] = override({}, val);\n          }\n        } else {\n          target[key] = override(src, val);\n        }\n        return;\n      });\n    }\n  });\n  return target;\n}","vector":"function override ( ... rawArgs ) { if ( rawArgs . length < 1 || typeof rawArgs [ 0 ] !== 'object' ) return false ; if ( rawArgs . length < 2 ) return rawArgs [ 0 ] ; const varName1 = rawArgs [ 0 ] ; const varName2 = Array . prototype . slice . call ( rawArgs , 1 ) ; let varName3 , varName4 ; varName2 . forEach ( varName8 => { if ( typeof varName8 !== 'object' ) return ; if ( Array . isArray ( varName8 ) ) { varName8 . forEach ( ( varName5 , varName6 ) => { varName4 = varName1 [ index ] ; varName3 = varName8 [ index ] ; if ( varName3 === varName1 ) { } else if ( typeof varName3 !== 'object' || varName3 === null ) { varName1 [ index ] = varName3 ; } else if ( isSpecificValue ( varName3 ) ) { varName1 [ index ] = cloneSpecificValue ( varName3 ) ; } else if ( typeof varName4 !== 'object' || varName4 === null ) { if ( Array . isArray ( varName3 ) ) { varName1 [ index ] = override ( [ ] , varName3 ) ; } else { varName1 [ index ] = override ( { } , varName3 ) ; } } else { varName1 [ index ] = override ( varName4 , varName3 ) ; } return ; } ) ; } else { Object . keys ( varName8 ) . forEach ( varName7 => { varName4 = varName1 [ key ] ; varName3 = varName8 [ key ] ; if ( varName3 === varName1 ) { } else if ( typeof varName3 !== 'object' || varName3 === null ) { varName1 [ key ] = varName3 ; } else if ( isSpecificValue ( varName3 ) ) { varName1 [ key ] = cloneSpecificValue ( varName3 ) ; } else if ( typeof varName4 !== 'object' || varName4 === null ) { if ( Array . isArray ( varName3 ) ) { varName1 [ key ] = override ( [ ] , varName3 ) ; } else { varName1 [ key ] = override ( { } , varName3 ) ; } } else { varName1 [ key ] = override ( varName4 , varName3 ) ; } return ; } ) ; } } ) ; return varName1 ; }","hash":"7b6faa53f6ef676585415eb87875f987f9bb515a","simhash":4575151367094771000,"link":"https://github.com/ASaiAnudeep/deep-override/commit/2aced17651fb684959a6e04b1465a8329b3d5268","page":"https://snyk.io/vuln/SNYK-JS-DEEPOVERRIDE-1292344","CVE":"CVE-2021-25941","CWE":"CWE-1321","packageName":"deep-override","versions":"<1.0.2","details":"Prototype Pollution. deep-override is a recursive object extending &amp; overridingAffected versions of this package are vulnerable to Prototype Pollution in &#39;deep-override&#39;. It allows an attacker to cause a denial of service and may lead to remote code execution.","vulnType":"Prototype Pollution","fileLink":"https://github.com/ASaiAnudeep/deep-override/raw/393135641fb0891409ac2a53783c553a7ed749a9/src/index.js","protoPollution":true,"matches":[]},
{"function":"function htmlEncode(text) {\n  return document.createElement('a').appendChild( document.createTextNode(text) ).parentNode.innerHTML;\n}","vector":"function htmlEncode ( varName1 ) { return document . createElement ( 'a' ) . appendChild ( document . createTextNode ( varName1 ) ) . parentNode . innerHTML ; }","hash":"e2e90091c1797df02c82c13069b9c3784450d93f","simhash":12679362743646478000,"link":"https://github.com/Tencent/vConsole/commit/365380a1d1700643ac81782b2262a1edb02ff033","page":"https://snyk.io/vuln/SNYK-JS-VCONSOLE-1292147","CWE":"CWE-79","packageName":"vconsole","versions":"<3.5.2","details":"Cross-site Scripting (XSS). vconsole is an A lightweight, extendable front-end developer tool for mobile web page.Affected versions of this package are vulnerable to Cross-site Scripting (XSS) vulnerability.","vulnType":"Cross-site Scripting (XSS)","fileLink":"https://github.com/Tencent/vConsole/raw/bb89dcd34717cc9f380ea5cca791e0732fe4cf7f/src/lib/tool.js","protoPollution":true,"matches":[]},
